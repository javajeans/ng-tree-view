{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","ng-tree-view.min.js","node_modules/async/lib/async.js","node_modules/browserify/node_modules/process/browser.js","src/directive.compiled.js","src/index.js","src/ng-tree-view.controller.js","src/ng-tree-view.directive.js","src/templates.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","process","global","noop","identity","v","toBool","notId","only_once","fn","apply","this","arguments","_once","_isArrayLike","arr","_isArray","_arrayEach","iterator","index","_map","result","Array","_range","count","_reduce","memo","x","_forEachOf","object","_keys","key","_indexOf","item","_keyIterator","coll","len","keys","_restParam","func","startIndex","Math","max","rest","_withoutIndex","value","callback","_eachOfLimit","limit","obj","nextKey","done","running","errored","replenish","err","doParallel","async","eachOf","doParallelLimit","doSeries","eachOfSeries","_asyncMap","eachfn","results","_filter","push","sort","b","_reject","cb","_createTester","check","getResult","iteratee","_","_findGetResult","_parallel","tasks","task","args","_concat","y","concat","_queue","worker","concurrency","payload","_insert","q","data","pos","started","idle","setImmediate","drain","unshift","saturated","_next","workers","removed","workersList","splice","empty","paused","kill","pause","resume","resumeCount","min","w","_console_fn","name","console","error","_times","mapper","_applyEach","fns","go","that","pop","ensureAsync","innerArgs","sync","previous_async","root","self","noConflict","_toString","Object","prototype","toString","isArray","_isObject","type","k","hasOwnProperty","_setImmediate","_delay","setTimeout","nextTick","forEach","each","forEachSeries","eachSeries","forEachLimit","eachLimit","forEachOf","completed","iter","forEachOfSeries","iterate","forEachOfLimit","eachOfLimit","map","mapSeries","mapLimit","inject","foldl","reduce","foldr","reduceRight","reversed","reverse","transform","select","filter","selectLimit","filterLimit","selectSeries","filterSeries","reject","rejectLimit","rejectSeries","any","some","someLimit","all","every","everyLimit","detect","detectSeries","detectLimit","sortBy","comparator","left","right","criteria","auto","addListener","listeners","removeListener","idx","taskComplete","remainingTasks","slice","runningTasks","hasError","ready","requires","listener","taskCallback","dep","safeResults","val","rkey","join","retry","times","parseTimes","acc","parseInt","DEFAULT_TIMES","interval","DEFAULT_INTERVAL","wrappedTask","wrappedCallback","wrappedResults","retryAttempt","finalAttempt","seriesCallback","retryInterval","opts","attempts","series","waterfall","wrapIterator","next","parallel","parallelLimit","makeCallback","callArgs","concatSeries","whilst","test","doWhilst","calls","until","doUntil","during","truth","doDuring","queue","items","priorityQueue","_compareTasks","priority","_binarySearch","sequence","compare","beg","end","mid","cargo","log","dir","memoize","hasher","queues","has","memoized","unmemoized","unmemoize","timesSeries","timesLimit","seq","newargs","nextargs","compose","applyEach","applyEachSeries","forever","constant","values","wrapSync","asyncify","then","message","define","amd","window","_process",2,"cleanUpNextTick","draining","currentQueue","queueIndex","drainQueue","timeout","run","clearTimeout","Item","fun","array","title","browser","env","argv","version","versions","on","once","off","removeAllListeners","emit","binding","cwd","chdir","umask",3,"defineProperty","$compile","restrict","replace","link","scope","ele","attrs","$watch","compiled","html","contents",4,"_interopRequireDefault","__esModule","default","_ngTreeView","_ngTreeView2","_directive","_directive2","_ngTreeView3","_ngTreeView4","angular","controller","directive","./directive.compiled","./ng-tree-view.controller","./ng-tree-view.directive",5,"_async","_templates","_templates2","$scope","$timeout","$q","templates","cache","options","id","_options","lazy","indicators","extend","folded","unfolded","loading","_lastSelectedItem","shouldLoad","onSelect","d","deer","resolve","promise","itemSelected","_ngTree","selected","load","defer","pre","toggleFolding","status","_shouldLoad","children","_initItems","c","parent","_initItem","tree","./templates",6,"template","element","attributes",7],"mappings":"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","file":"ng-tree-view.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process,global){\n/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n(function () {\n\n    var async = {};\n    function noop() {}\n    function identity(v) {\n        return v;\n    }\n    function toBool(v) {\n        return !!v;\n    }\n    function notId(v) {\n        return !v;\n    }\n\n    // global on the server, window in the browser\n    var previous_async;\n\n    // Establish the root object, `window` (`self`) in the browser, `global`\n    // on the server, or `this` in some virtual machines. We use `self`\n    // instead of `window` for `WebWorker` support.\n    var root = typeof self === 'object' && self.self === self && self ||\n            typeof global === 'object' && global.global === global && global ||\n            this;\n\n    if (root != null) {\n        previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        return function() {\n            if (fn === null) throw new Error(\"Callback was already called.\");\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    function _once(fn) {\n        return function() {\n            if (fn === null) return;\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    // Ported from underscore.js isObject\n    var _isObject = function(obj) {\n        var type = typeof obj;\n        return type === 'function' || type === 'object' && !!obj;\n    };\n\n    function _isArrayLike(arr) {\n        return _isArray(arr) || (\n            // has a positive integer length property\n            typeof arr.length === \"number\" &&\n            arr.length >= 0 &&\n            arr.length % 1 === 0\n        );\n    }\n\n    function _arrayEach(arr, iterator) {\n        var index = -1,\n            length = arr.length;\n\n        while (++index < length) {\n            iterator(arr[index], index, arr);\n        }\n    }\n\n    function _map(arr, iterator) {\n        var index = -1,\n            length = arr.length,\n            result = Array(length);\n\n        while (++index < length) {\n            result[index] = iterator(arr[index], index, arr);\n        }\n        return result;\n    }\n\n    function _range(count) {\n        return _map(Array(count), function (v, i) { return i; });\n    }\n\n    function _reduce(arr, iterator, memo) {\n        _arrayEach(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    }\n\n    function _forEachOf(object, iterator) {\n        _arrayEach(_keys(object), function (key) {\n            iterator(object[key], key);\n        });\n    }\n\n    function _indexOf(arr, item) {\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] === item) return i;\n        }\n        return -1;\n    }\n\n    var _keys = Object.keys || function (obj) {\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    function _keyIterator(coll) {\n        var i = -1;\n        var len;\n        var keys;\n        if (_isArrayLike(coll)) {\n            len = coll.length;\n            return function next() {\n                i++;\n                return i < len ? i : null;\n            };\n        } else {\n            keys = _keys(coll);\n            len = keys.length;\n            return function next() {\n                i++;\n                return i < len ? keys[i] : null;\n            };\n        }\n    }\n\n    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n    // This accumulates the arguments passed into an array, after a given index.\n    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).\n    function _restParam(func, startIndex) {\n        startIndex = startIndex == null ? func.length - 1 : +startIndex;\n        return function() {\n            var length = Math.max(arguments.length - startIndex, 0);\n            var rest = Array(length);\n            for (var index = 0; index < length; index++) {\n                rest[index] = arguments[index + startIndex];\n            }\n            switch (startIndex) {\n                case 0: return func.call(this, rest);\n                case 1: return func.call(this, arguments[0], rest);\n            }\n            // Currently unused but handle cases outside of the switch statement:\n            // var args = Array(startIndex + 1);\n            // for (index = 0; index < startIndex; index++) {\n            //     args[index] = arguments[index];\n            // }\n            // args[startIndex] = rest;\n            // return func.apply(this, args);\n        };\n    }\n\n    function _withoutIndex(iterator) {\n        return function (value, index, callback) {\n            return iterator(value, callback);\n        };\n    }\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n\n    // capture the global reference to guard against fakeTimer mocks\n    var _setImmediate = typeof setImmediate === 'function' && setImmediate;\n\n    var _delay = _setImmediate ? function(fn) {\n        // not a direct alias for IE10 compatibility\n        _setImmediate(fn);\n    } : function(fn) {\n        setTimeout(fn, 0);\n    };\n\n    if (typeof process === 'object' && typeof process.nextTick === 'function') {\n        async.nextTick = process.nextTick;\n    } else {\n        async.nextTick = _delay;\n    }\n    async.setImmediate = _setImmediate ? _delay : async.nextTick;\n\n\n    async.forEach =\n    async.each = function (arr, iterator, callback) {\n        return async.eachOf(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachSeries =\n    async.eachSeries = function (arr, iterator, callback) {\n        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);\n    };\n\n\n    async.forEachLimit =\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachOf =\n    async.eachOf = function (object, iterator, callback) {\n        callback = _once(callback || noop);\n        object = object || [];\n\n        var iter = _keyIterator(object);\n        var key, completed = 0;\n\n        while ((key = iter()) != null) {\n            completed += 1;\n            iterator(object[key], key, only_once(done));\n        }\n\n        if (completed === 0) callback(null);\n\n        function done(err) {\n            completed--;\n            if (err) {\n                callback(err);\n            }\n            // Check key is null in case iterator isn't exhausted\n            // and done resolved synchronously.\n            else if (key === null && completed <= 0) {\n                callback(null);\n            }\n        }\n    };\n\n    async.forEachOfSeries =\n    async.eachOfSeries = function (obj, iterator, callback) {\n        callback = _once(callback || noop);\n        obj = obj || [];\n        var nextKey = _keyIterator(obj);\n        var key = nextKey();\n        function iterate() {\n            var sync = true;\n            if (key === null) {\n                return callback(null);\n            }\n            iterator(obj[key], key, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    key = nextKey();\n                    if (key === null) {\n                        return callback(null);\n                    } else {\n                        if (sync) {\n                            async.setImmediate(iterate);\n                        } else {\n                            iterate();\n                        }\n                    }\n                }\n            }));\n            sync = false;\n        }\n        iterate();\n    };\n\n\n\n    async.forEachOfLimit =\n    async.eachOfLimit = function (obj, limit, iterator, callback) {\n        _eachOfLimit(limit)(obj, iterator, callback);\n    };\n\n    function _eachOfLimit(limit) {\n\n        return function (obj, iterator, callback) {\n            callback = _once(callback || noop);\n            obj = obj || [];\n            var nextKey = _keyIterator(obj);\n            if (limit <= 0) {\n                return callback(null);\n            }\n            var done = false;\n            var running = 0;\n            var errored = false;\n\n            (function replenish () {\n                if (done && running <= 0) {\n                    return callback(null);\n                }\n\n                while (running < limit && !errored) {\n                    var key = nextKey();\n                    if (key === null) {\n                        done = true;\n                        if (running <= 0) {\n                            callback(null);\n                        }\n                        return;\n                    }\n                    running += 1;\n                    iterator(obj[key], key, only_once(function (err) {\n                        running -= 1;\n                        if (err) {\n                            callback(err);\n                            errored = true;\n                        }\n                        else {\n                            replenish();\n                        }\n                    }));\n                }\n            })();\n        };\n    }\n\n\n    function doParallel(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOf, obj, iterator, callback);\n        };\n    }\n    function doParallelLimit(fn) {\n        return function (obj, limit, iterator, callback) {\n            return fn(_eachOfLimit(limit), obj, iterator, callback);\n        };\n    }\n    function doSeries(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOfSeries, obj, iterator, callback);\n        };\n    }\n\n    function _asyncMap(eachfn, arr, iterator, callback) {\n        callback = _once(callback || noop);\n        arr = arr || [];\n        var results = _isArrayLike(arr) ? [] : {};\n        eachfn(arr, function (value, index, callback) {\n            iterator(value, function (err, v) {\n                results[index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = doParallelLimit(_asyncMap);\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.inject =\n    async.foldl =\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachOfSeries(arr, function (x, i, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n\n    async.foldr =\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, identity).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n\n    async.transform = function (arr, memo, iterator, callback) {\n        if (arguments.length === 3) {\n            callback = iterator;\n            iterator = memo;\n            memo = _isArray(arr) ? [] : {};\n        }\n\n        async.eachOf(arr, function(v, k, cb) {\n            iterator(memo, v, k, cb);\n        }, function(err) {\n            callback(err, memo);\n        });\n    };\n\n    function _filter(eachfn, arr, iterator, callback) {\n        var results = [];\n        eachfn(arr, function (x, index, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            });\n        }, function () {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    }\n\n    async.select =\n    async.filter = doParallel(_filter);\n\n    async.selectLimit =\n    async.filterLimit = doParallelLimit(_filter);\n\n    async.selectSeries =\n    async.filterSeries = doSeries(_filter);\n\n    function _reject(eachfn, arr, iterator, callback) {\n        _filter(eachfn, arr, function(value, cb) {\n            iterator(value, function(v) {\n                cb(!v);\n            });\n        }, callback);\n    }\n    async.reject = doParallel(_reject);\n    async.rejectLimit = doParallelLimit(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    function _createTester(eachfn, check, getResult) {\n        return function(arr, limit, iterator, cb) {\n            function done() {\n                if (cb) cb(getResult(false, void 0));\n            }\n            function iteratee(x, _, callback) {\n                if (!cb) return callback();\n                iterator(x, function (v) {\n                    if (cb && check(v)) {\n                        cb(getResult(true, x));\n                        cb = iterator = false;\n                    }\n                    callback();\n                });\n            }\n            if (arguments.length > 3) {\n                eachfn(arr, limit, iteratee, done);\n            } else {\n                cb = iterator;\n                iterator = limit;\n                eachfn(arr, iteratee, done);\n            }\n        };\n    }\n\n    async.any =\n    async.some = _createTester(async.eachOf, toBool, identity);\n\n    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);\n\n    async.all =\n    async.every = _createTester(async.eachOf, notId, notId);\n\n    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);\n\n    function _findGetResult(v, x) {\n        return x;\n    }\n    async.detect = _createTester(async.eachOf, identity, _findGetResult);\n    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);\n    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                callback(null, _map(results.sort(comparator), function (x) {\n                    return x.value;\n                }));\n            }\n\n        });\n\n        function comparator(left, right) {\n            var a = left.criteria, b = right.criteria;\n            return a < b ? -1 : a > b ? 1 : 0;\n        }\n    };\n\n    async.auto = function (tasks, concurrency, callback) {\n        if (typeof arguments[1] === 'function') {\n            // concurrency is optional, shift the args.\n            callback = concurrency;\n            concurrency = null;\n        }\n        callback = _once(callback || noop);\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length;\n        if (!remainingTasks) {\n            return callback(null);\n        }\n        if (!concurrency) {\n            concurrency = remainingTasks;\n        }\n\n        var results = {};\n        var runningTasks = 0;\n\n        var hasError = false;\n\n        var listeners = [];\n        function addListener(fn) {\n            listeners.unshift(fn);\n        }\n        function removeListener(fn) {\n            var idx = _indexOf(listeners, fn);\n            if (idx >= 0) listeners.splice(idx, 1);\n        }\n        function taskComplete() {\n            remainingTasks--;\n            _arrayEach(listeners.slice(0), function (fn) {\n                fn();\n            });\n        }\n\n        addListener(function () {\n            if (!remainingTasks) {\n                callback(null, results);\n            }\n        });\n\n        _arrayEach(keys, function (k) {\n            if (hasError) return;\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = _restParam(function(err, args) {\n                runningTasks--;\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _forEachOf(results, function(val, rkey) {\n                        safeResults[rkey] = val;\n                    });\n                    safeResults[k] = args;\n                    hasError = true;\n\n                    callback(err, safeResults);\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            });\n            var requires = task.slice(0, task.length - 1);\n            // prevent dead-locks\n            var len = requires.length;\n            var dep;\n            while (len--) {\n                if (!(dep = tasks[requires[len]])) {\n                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));\n                }\n                if (_isArray(dep) && _indexOf(dep, k) >= 0) {\n                    throw new Error('Has cyclic dependencies');\n                }\n            }\n            function ready() {\n                return runningTasks < concurrency && _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            }\n            if (ready()) {\n                runningTasks++;\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                addListener(listener);\n            }\n            function listener() {\n                if (ready()) {\n                    runningTasks++;\n                    removeListener(listener);\n                    task[task.length - 1](taskCallback, results);\n                }\n            }\n        });\n    };\n\n\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var DEFAULT_INTERVAL = 0;\n\n        var attempts = [];\n\n        var opts = {\n            times: DEFAULT_TIMES,\n            interval: DEFAULT_INTERVAL\n        };\n\n        function parseTimes(acc, t){\n            if(typeof t === 'number'){\n                acc.times = parseInt(t, 10) || DEFAULT_TIMES;\n            } else if(typeof t === 'object'){\n                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;\n                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;\n            } else {\n                throw new Error('Unsupported argument type for \\'times\\': ' + typeof t);\n            }\n        }\n\n        var length = arguments.length;\n        if (length < 1 || length > 3) {\n            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');\n        } else if (length <= 2 && typeof times === 'function') {\n            callback = task;\n            task = times;\n        }\n        if (typeof times !== 'function') {\n            parseTimes(opts, times);\n        }\n        opts.callback = callback;\n        opts.task = task;\n\n        function wrappedTask(wrappedCallback, wrappedResults) {\n            function retryAttempt(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            }\n\n            function retryInterval(interval){\n                return function(seriesCallback){\n                    setTimeout(function(){\n                        seriesCallback(null);\n                    }, interval);\n                };\n            }\n\n            while (opts.times) {\n\n                var finalAttempt = !(opts.times-=1);\n                attempts.push(retryAttempt(opts.task, finalAttempt));\n                if(!finalAttempt && opts.interval > 0){\n                    attempts.push(retryInterval(opts.interval));\n                }\n            }\n\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || opts.callback)(data.err, data.result);\n            });\n        }\n\n        // If a callback is passed, run this as a controll flow\n        return opts.callback ? wrappedTask() : wrappedTask;\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = _once(callback || noop);\n        if (!_isArray(tasks)) {\n            var err = new Error('First argument to waterfall must be an array of functions');\n            return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        function wrapIterator(iterator) {\n            return _restParam(function (err, args) {\n                if (err) {\n                    callback.apply(null, [err].concat(args));\n                }\n                else {\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    ensureAsync(iterator).apply(null, args);\n                }\n            });\n        }\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    function _parallel(eachfn, tasks, callback) {\n        callback = callback || noop;\n        var results = _isArrayLike(tasks) ? [] : {};\n\n        eachfn(tasks, function (task, key, callback) {\n            task(_restParam(function (err, args) {\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                results[key] = args;\n                callback(err);\n            }));\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.parallel = function (tasks, callback) {\n        _parallel(async.eachOf, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel(_eachOfLimit(limit), tasks, callback);\n    };\n\n    async.series = function(tasks, callback) {\n        _parallel(async.eachOfSeries, tasks, callback);\n    };\n\n    async.iterator = function (tasks) {\n        function makeCallback(index) {\n            function fn() {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            }\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        }\n        return makeCallback(0);\n    };\n\n    async.apply = _restParam(function (fn, args) {\n        return _restParam(function (callArgs) {\n            return fn.apply(\n                null, args.concat(callArgs)\n            );\n        });\n    });\n\n    function _concat(eachfn, arr, fn, callback) {\n        var result = [];\n        eachfn(arr, function (x, index, cb) {\n            fn(x, function (err, y) {\n                result = result.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, result);\n        });\n    }\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        callback = callback || noop;\n        if (test()) {\n            var next = _restParam(function(err, args) {\n                if (err) {\n                    callback(err);\n                } else if (test.apply(this, args)) {\n                    iterator(next);\n                } else {\n                    callback.apply(null, [null].concat(args));\n                }\n            });\n            iterator(next);\n        } else {\n            callback(null);\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        var calls = 0;\n        return async.whilst(function() {\n            return ++calls <= 1 || test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.until = function (test, iterator, callback) {\n        return async.whilst(function() {\n            return !test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        return async.doWhilst(iterator, function() {\n            return !test.apply(this, arguments);\n        }, callback);\n    };\n\n    async.during = function (test, iterator, callback) {\n        callback = callback || noop;\n\n        var next = _restParam(function(err, args) {\n            if (err) {\n                callback(err);\n            } else {\n                args.push(check);\n                test.apply(this, args);\n            }\n        });\n\n        var check = function(err, truth) {\n            if (err) {\n                callback(err);\n            } else if (truth) {\n                iterator(next);\n            } else {\n                callback(null);\n            }\n        };\n\n        test(check);\n    };\n\n    async.doDuring = function (iterator, test, callback) {\n        var calls = 0;\n        async.during(function(next) {\n            if (calls++ < 1) {\n                next(null, true);\n            } else {\n                test.apply(this, arguments);\n            }\n        }, iterator, callback);\n    };\n\n    function _queue(worker, concurrency, payload) {\n        if (concurrency == null) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new Error('Concurrency must not be zero');\n        }\n        function _insert(q, data, pos, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0 && q.idle()) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    callback: callback || noop\n                };\n\n                if (pos) {\n                    q.tasks.unshift(item);\n                } else {\n                    q.tasks.push(item);\n                }\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n            });\n            async.setImmediate(q.process);\n        }\n        function _next(q, tasks) {\n            return function(){\n                workers -= 1;\n\n                var removed = false;\n                var args = arguments;\n                _arrayEach(tasks, function (task) {\n                    _arrayEach(workersList, function (worker, index) {\n                        if (worker === task && !removed) {\n                            workersList.splice(index, 1);\n                            removed = true;\n                        }\n                    });\n\n                    task.callback.apply(task, args);\n                });\n                if (q.tasks.length + workers === 0) {\n                    q.drain();\n                }\n                q.process();\n            };\n        }\n\n        var workers = 0;\n        var workersList = [];\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            payload: payload,\n            saturated: noop,\n            empty: noop,\n            drain: noop,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n                _insert(q, data, false, callback);\n            },\n            kill: function () {\n                q.drain = noop;\n                q.tasks = [];\n            },\n            unshift: function (data, callback) {\n                _insert(q, data, true, callback);\n            },\n            process: function () {\n                while(!q.paused && workers < q.concurrency && q.tasks.length){\n\n                    var tasks = q.payload ?\n                        q.tasks.splice(0, q.payload) :\n                        q.tasks.splice(0, q.tasks.length);\n\n                    var data = _map(tasks, function (task) {\n                        return task.data;\n                    });\n\n                    if (q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    workersList.push(tasks[0]);\n                    var cb = only_once(_next(q, tasks));\n                    worker(data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            workersList: function () {\n                return workersList;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                var resumeCount = Math.min(q.concurrency, q.tasks.length);\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= resumeCount; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    }\n\n    async.queue = function (worker, concurrency) {\n        var q = _queue(function (items, cb) {\n            worker(items[0], cb);\n        }, concurrency, 1);\n\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n            return a.priority - b.priority;\n        }\n\n        function _binarySearch(sequence, item, compare) {\n            var beg = -1,\n                end = sequence.length - 1;\n            while (beg < end) {\n                var mid = beg + ((end - beg + 1) >>> 1);\n                if (compare(item, sequence[mid]) >= 0) {\n                    beg = mid;\n                } else {\n                    end = mid - 1;\n                }\n            }\n            return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    priority: priority,\n                    callback: typeof callback === 'function' ? callback : noop\n                };\n\n                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n                async.setImmediate(q.process);\n            });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n            _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        return _queue(worker, 1, payload);\n    };\n\n    function _console_fn(name) {\n        return _restParam(function (fn, args) {\n            fn.apply(null, args.concat([_restParam(function (err, args) {\n                if (typeof console === 'object') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _arrayEach(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            })]));\n        });\n    }\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        var has = Object.prototype.hasOwnProperty;\n        hasher = hasher || identity;\n        var memoized = _restParam(function memoized(args) {\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (has.call(memo, key)) {   \n                async.setImmediate(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (has.call(queues, key)) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([_restParam(function (args) {\n                    memo[key] = args;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                        q[i].apply(null, args);\n                    }\n                })]));\n            }\n        });\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n        return function () {\n            return (fn.unmemoized || fn).apply(null, arguments);\n        };\n    };\n\n    function _times(mapper) {\n        return function (count, iterator, callback) {\n            mapper(_range(count), iterator, callback);\n        };\n    }\n\n    async.times = _times(async.map);\n    async.timesSeries = _times(async.mapSeries);\n    async.timesLimit = function (count, limit, iterator, callback) {\n        return async.mapLimit(_range(count), limit, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return _restParam(function (args) {\n            var that = this;\n\n            var callback = args[args.length - 1];\n            if (typeof callback == 'function') {\n                args.pop();\n            } else {\n                callback = noop;\n            }\n\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {\n                    cb(err, nextargs);\n                })]));\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        });\n    };\n\n    async.compose = function (/* functions... */) {\n        return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n\n    function _applyEach(eachfn) {\n        return _restParam(function(fns, args) {\n            var go = _restParam(function(args) {\n                var that = this;\n                var callback = args.pop();\n                return eachfn(fns, function (fn, _, cb) {\n                    fn.apply(that, args.concat([cb]));\n                },\n                callback);\n            });\n            if (args.length) {\n                return go.apply(this, args);\n            }\n            else {\n                return go;\n            }\n        });\n    }\n\n    async.applyEach = _applyEach(async.eachOf);\n    async.applyEachSeries = _applyEach(async.eachOfSeries);\n\n\n    async.forever = function (fn, callback) {\n        var done = only_once(callback || noop);\n        var task = ensureAsync(fn);\n        function next(err) {\n            if (err) {\n                return done(err);\n            }\n            task(next);\n        }\n        next();\n    };\n\n    function ensureAsync(fn) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            args.push(function () {\n                var innerArgs = arguments;\n                if (sync) {\n                    async.setImmediate(function () {\n                        callback.apply(null, innerArgs);\n                    });\n                } else {\n                    callback.apply(null, innerArgs);\n                }\n            });\n            var sync = true;\n            fn.apply(this, args);\n            sync = false;\n        });\n    }\n\n    async.ensureAsync = ensureAsync;\n\n    async.constant = _restParam(function(values) {\n        var args = [null].concat(values);\n        return function (callback) {\n            return callback.apply(this, args);\n        };\n    });\n\n    async.wrapSync =\n    async.asyncify = function asyncify(func) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            var result;\n            try {\n                result = func.apply(this, args);\n            } catch (e) {\n                return callback(e);\n            }\n            // if result is Promise object\n            if (_isObject(result) && typeof result.then === \"function\") {\n                result.then(function(value) {\n                    callback(null, value);\n                })[\"catch\"](function(err) {\n                    callback(err.message ? err : new Error(err));\n                });\n            } else {\n                callback(null, result);\n            }\n        });\n    };\n\n    // Node.js\n    if (typeof module === 'object' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define === 'function' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"_process\":2}],2:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],3:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function ($compile) {\n  'ngInject';\n\n  return {\n    restrict: 'A',\n    replace: true,\n    link: function link(scope, ele, attrs) {\n      scope.$watch(attrs.compiled, function (html) {\n        ele.html(html);\n        $compile(ele.contents())(scope);\n      });\n    }\n  };\n};\n\n},{}],4:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar _ngTreeView = require('./ng-tree-view.directive');\n\nvar _ngTreeView2 = _interopRequireDefault(_ngTreeView);\n\nvar _directive = require('./directive.compiled');\n\nvar _directive2 = _interopRequireDefault(_directive);\n\nvar _ngTreeView3 = require('./ng-tree-view.controller');\n\nvar _ngTreeView4 = _interopRequireDefault(_ngTreeView3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar angular = (typeof window !== \"undefined\" ? window['angular'] : typeof global !== \"undefined\" ? global['angular'] : null);\n\nangular.module('ngTreeView', []).controller('NgTreeViewController', _ngTreeView4.default).directive('ngTreeView', _ngTreeView2.default).directive('compiled', _directive2.default);\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./directive.compiled\":3,\"./ng-tree-view.controller\":5,\"./ng-tree-view.directive\":6}],5:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _async = require('async');\n\nvar _async2 = _interopRequireDefault(_async);\n\nvar _templates = require('./templates');\n\nvar _templates2 = _interopRequireDefault(_templates);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function ($scope, $timeout, $q) {\n  'ngInject';\n\n  $scope.templates = _templates2.default;\n\n  $scope.cache = {};\n\n  $scope.options = {\n    id: $scope._options.id || 0,\n    lazy: $scope._options.lazy || false,\n    indicators: angular.extend({\n      folded: \"[+]\",\n      unfolded: \"[-]\",\n      loading: \"[...]\"\n    }, $scope._options.indicators || {})\n  };\n\n  $scope._lastSelectedItem = null;\n\n  $scope.shouldLoad = $scope._options.shouldLoad || function (item) {\n    return true;\n  };\n\n  $scope.onSelect = $scope._options.onSelect || function (item) {\n    var d = $q.deer();\n    d.resolve();\n    return d.promise;\n  };\n\n  $scope.itemSelected = function (item) {\n    $scope.onSelect(item).then(function () {\n      if ($scope._lastSelectedItem) {\n        $scope._lastSelectedItem._ngTree.selected = false;\n      }\n\n      item._ngTree.selected = true;\n      $scope._lastSelectedItem = item;\n    });\n  };\n\n  $scope.load = $scope._options.load || function (item) {\n    var d = $q.defer();\n    d.resolve([]);\n    return d.promise;\n  };\n\n  $scope.pre = $scope._options.pre || function (item) {\n    var d = $q.defer();\n    d.resolve([]);\n    return d.promise;\n  };\n\n  $scope.toggleFolding = function (item, next) {\n    next = next || function () {};\n\n    // Return if it is already unfolded state\n    if (!item._ngTree.folded) {\n      item._ngTree.folded = true;\n      return next(null, item);\n    }\n\n    // Return if it is already loaded\n    //console.log(item.name + ' -> ' + JSON.stringify(item._ngTree));\n\n    if (item._ngTree.status === 'loaded') {\n      item._ngTree.folded = !item._ngTree.folded;\n      return next(null, item);\n    }\n\n    var _shouldLoad = $scope.options.lazy || false;\n\n    if (item._options && item._options.hasOwnProperty('lazy')) {\n      _shouldLoad = item._options.lazy;\n    }\n\n    if (!_shouldLoad) {\n      item._ngTree.folded = !item._ngTree.folded;\n      return next(null, item);\n    }\n\n    item._ngTree.status = 'loading';\n\n    $scope.load(item).then(function (children) {\n      item.children = $scope._initItems(children);\n      item._ngTree.status = 'loaded';\n      item._ngTree.folded = !item._ngTree.folded;\n      item.children.forEach(function (c) {\n        c.parent = item.id.toString();\n      });\n    });\n  };\n\n  $scope._initItem = function (item) {\n    item._ngTree = angular.extend(item._ngTree || {\n      folded: true,\n      selected: false\n    }, item._options || {});\n\n    if (!angular.isArray(item.children || [])) {\n      item.children = [];\n    }\n\n    if (item._ngTree.selected) {\n      $scope._lastSelectedItem = item;\n    }\n\n    $scope.cache[item.id.toString()] = item;\n\n    if (!item._ngTree.folded) {\n      item._ngTree.folded = !item._ngTree.folded;\n      $scope.toggleFolding(item);\n    }\n\n    return item;\n  };\n\n  $scope._initItems = function (items) {\n    return items.map(function (item) {\n      return $scope._initItem(item);\n    });\n  };\n\n  $scope.tree = $scope._initItems($scope._options.data);\n\n  //$scope.pre()\n  //.then((path) => {\n  //async.mapSeries(path || [], (id, next) => {\n  //if (!$scope.cache[id]) return next();\n  //$scope.toggleFolding($scope.cache[id], next);\n  //}, (err, items) => {\n  //if (err) return console.log('couldnt load path');\n\n  //if (items.length) {\n  //var lastItem = $scope.cache[path[path.length - 1]];\n  //$scope.itemSelected(lastItem);\n  //}\n  //});\n  //});\n};\n\n},{\"./templates\":7,\"async\":1}],6:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _templates = require('./templates');\n\nvar _templates2 = _interopRequireDefault(_templates);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  'ngInject';\n\n  return {\n    template: _templates2.default.tree,\n    scope: {\n      _options: '=ngTreeView'\n    },\n    controller: 'NgTreeViewController',\n    link: function link(scope, element, attributes) {}\n  };\n};\n\n},{\"./templates\":7}],7:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tree = function tree() {\n  return '\\n  <ul>\\n    <li ng-repeat=\"item in tree track by $index\" compiled=\"templates.item\" ng-class=\"{\\'selected\\': item._ngTree.selected}\"></li>\\n  </ul>\\n';\n};\n\nvar item = function item() {\n  return '\\n  <div class=\\'ng-tree-item-content\\'>\\n    <span ng-show=\"item._ngTree.status !== \\'loading\\'\">\\n      <span ng-click=\"toggleFolding(item)\" ng-show=\"item._ngTree.folded\" compiled=\"options.indicators.folded\"></span>\\n      <span ng-click=\"toggleFolding(item)\" ng-show=\"!item._ngTree.folded\" compiled=\"options.indicators.unfolded\"></span>\\n    </span>\\n\\n    <span ng-show=\"item._ngTree.status === \\'loading\\'\" compiled=\"options.indicators.loading\"></span>\\n\\n    <div class=\"folder-name\" ng-class=\"{\\'selected\\': item._ngTree.selected}\">\\n      <a href=\"#\" ng-click=\"itemSelected(item)\">\\n        {{item.name}}\\n      </a>\\n    </div>\\n\\n  </div>\\n\\n  <ul ng-if=\"!item._ngTree.folded\">\\n    <li ng-repeat=\"item in item.children track by $index\" compiled=\"templates.item\" ng-class=\"{\\'selected\\': item._ngTree.selected}\"></li>\\n  </ul>\\n';\n};\n\nexports.default = {\n  item: item(),\n  tree: tree()\n};\n\n},{}]},{},[4])\n\n","/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n(function () {\n\n    var async = {};\n    function noop() {}\n    function identity(v) {\n        return v;\n    }\n    function toBool(v) {\n        return !!v;\n    }\n    function notId(v) {\n        return !v;\n    }\n\n    // global on the server, window in the browser\n    var previous_async;\n\n    // Establish the root object, `window` (`self`) in the browser, `global`\n    // on the server, or `this` in some virtual machines. We use `self`\n    // instead of `window` for `WebWorker` support.\n    var root = typeof self === 'object' && self.self === self && self ||\n            typeof global === 'object' && global.global === global && global ||\n            this;\n\n    if (root != null) {\n        previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        return function() {\n            if (fn === null) throw new Error(\"Callback was already called.\");\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    function _once(fn) {\n        return function() {\n            if (fn === null) return;\n            fn.apply(this, arguments);\n            fn = null;\n        };\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    // Ported from underscore.js isObject\n    var _isObject = function(obj) {\n        var type = typeof obj;\n        return type === 'function' || type === 'object' && !!obj;\n    };\n\n    function _isArrayLike(arr) {\n        return _isArray(arr) || (\n            // has a positive integer length property\n            typeof arr.length === \"number\" &&\n            arr.length >= 0 &&\n            arr.length % 1 === 0\n        );\n    }\n\n    function _arrayEach(arr, iterator) {\n        var index = -1,\n            length = arr.length;\n\n        while (++index < length) {\n            iterator(arr[index], index, arr);\n        }\n    }\n\n    function _map(arr, iterator) {\n        var index = -1,\n            length = arr.length,\n            result = Array(length);\n\n        while (++index < length) {\n            result[index] = iterator(arr[index], index, arr);\n        }\n        return result;\n    }\n\n    function _range(count) {\n        return _map(Array(count), function (v, i) { return i; });\n    }\n\n    function _reduce(arr, iterator, memo) {\n        _arrayEach(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    }\n\n    function _forEachOf(object, iterator) {\n        _arrayEach(_keys(object), function (key) {\n            iterator(object[key], key);\n        });\n    }\n\n    function _indexOf(arr, item) {\n        for (var i = 0; i < arr.length; i++) {\n            if (arr[i] === item) return i;\n        }\n        return -1;\n    }\n\n    var _keys = Object.keys || function (obj) {\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    function _keyIterator(coll) {\n        var i = -1;\n        var len;\n        var keys;\n        if (_isArrayLike(coll)) {\n            len = coll.length;\n            return function next() {\n                i++;\n                return i < len ? i : null;\n            };\n        } else {\n            keys = _keys(coll);\n            len = keys.length;\n            return function next() {\n                i++;\n                return i < len ? keys[i] : null;\n            };\n        }\n    }\n\n    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)\n    // This accumulates the arguments passed into an array, after a given index.\n    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).\n    function _restParam(func, startIndex) {\n        startIndex = startIndex == null ? func.length - 1 : +startIndex;\n        return function() {\n            var length = Math.max(arguments.length - startIndex, 0);\n            var rest = Array(length);\n            for (var index = 0; index < length; index++) {\n                rest[index] = arguments[index + startIndex];\n            }\n            switch (startIndex) {\n                case 0: return func.call(this, rest);\n                case 1: return func.call(this, arguments[0], rest);\n            }\n            // Currently unused but handle cases outside of the switch statement:\n            // var args = Array(startIndex + 1);\n            // for (index = 0; index < startIndex; index++) {\n            //     args[index] = arguments[index];\n            // }\n            // args[startIndex] = rest;\n            // return func.apply(this, args);\n        };\n    }\n\n    function _withoutIndex(iterator) {\n        return function (value, index, callback) {\n            return iterator(value, callback);\n        };\n    }\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n\n    // capture the global reference to guard against fakeTimer mocks\n    var _setImmediate = typeof setImmediate === 'function' && setImmediate;\n\n    var _delay = _setImmediate ? function(fn) {\n        // not a direct alias for IE10 compatibility\n        _setImmediate(fn);\n    } : function(fn) {\n        setTimeout(fn, 0);\n    };\n\n    if (typeof process === 'object' && typeof process.nextTick === 'function') {\n        async.nextTick = process.nextTick;\n    } else {\n        async.nextTick = _delay;\n    }\n    async.setImmediate = _setImmediate ? _delay : async.nextTick;\n\n\n    async.forEach =\n    async.each = function (arr, iterator, callback) {\n        return async.eachOf(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachSeries =\n    async.eachSeries = function (arr, iterator, callback) {\n        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);\n    };\n\n\n    async.forEachLimit =\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);\n    };\n\n    async.forEachOf =\n    async.eachOf = function (object, iterator, callback) {\n        callback = _once(callback || noop);\n        object = object || [];\n\n        var iter = _keyIterator(object);\n        var key, completed = 0;\n\n        while ((key = iter()) != null) {\n            completed += 1;\n            iterator(object[key], key, only_once(done));\n        }\n\n        if (completed === 0) callback(null);\n\n        function done(err) {\n            completed--;\n            if (err) {\n                callback(err);\n            }\n            // Check key is null in case iterator isn't exhausted\n            // and done resolved synchronously.\n            else if (key === null && completed <= 0) {\n                callback(null);\n            }\n        }\n    };\n\n    async.forEachOfSeries =\n    async.eachOfSeries = function (obj, iterator, callback) {\n        callback = _once(callback || noop);\n        obj = obj || [];\n        var nextKey = _keyIterator(obj);\n        var key = nextKey();\n        function iterate() {\n            var sync = true;\n            if (key === null) {\n                return callback(null);\n            }\n            iterator(obj[key], key, only_once(function (err) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    key = nextKey();\n                    if (key === null) {\n                        return callback(null);\n                    } else {\n                        if (sync) {\n                            async.setImmediate(iterate);\n                        } else {\n                            iterate();\n                        }\n                    }\n                }\n            }));\n            sync = false;\n        }\n        iterate();\n    };\n\n\n\n    async.forEachOfLimit =\n    async.eachOfLimit = function (obj, limit, iterator, callback) {\n        _eachOfLimit(limit)(obj, iterator, callback);\n    };\n\n    function _eachOfLimit(limit) {\n\n        return function (obj, iterator, callback) {\n            callback = _once(callback || noop);\n            obj = obj || [];\n            var nextKey = _keyIterator(obj);\n            if (limit <= 0) {\n                return callback(null);\n            }\n            var done = false;\n            var running = 0;\n            var errored = false;\n\n            (function replenish () {\n                if (done && running <= 0) {\n                    return callback(null);\n                }\n\n                while (running < limit && !errored) {\n                    var key = nextKey();\n                    if (key === null) {\n                        done = true;\n                        if (running <= 0) {\n                            callback(null);\n                        }\n                        return;\n                    }\n                    running += 1;\n                    iterator(obj[key], key, only_once(function (err) {\n                        running -= 1;\n                        if (err) {\n                            callback(err);\n                            errored = true;\n                        }\n                        else {\n                            replenish();\n                        }\n                    }));\n                }\n            })();\n        };\n    }\n\n\n    function doParallel(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOf, obj, iterator, callback);\n        };\n    }\n    function doParallelLimit(fn) {\n        return function (obj, limit, iterator, callback) {\n            return fn(_eachOfLimit(limit), obj, iterator, callback);\n        };\n    }\n    function doSeries(fn) {\n        return function (obj, iterator, callback) {\n            return fn(async.eachOfSeries, obj, iterator, callback);\n        };\n    }\n\n    function _asyncMap(eachfn, arr, iterator, callback) {\n        callback = _once(callback || noop);\n        arr = arr || [];\n        var results = _isArrayLike(arr) ? [] : {};\n        eachfn(arr, function (value, index, callback) {\n            iterator(value, function (err, v) {\n                results[index] = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = doParallelLimit(_asyncMap);\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.inject =\n    async.foldl =\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachOfSeries(arr, function (x, i, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n\n    async.foldr =\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, identity).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n\n    async.transform = function (arr, memo, iterator, callback) {\n        if (arguments.length === 3) {\n            callback = iterator;\n            iterator = memo;\n            memo = _isArray(arr) ? [] : {};\n        }\n\n        async.eachOf(arr, function(v, k, cb) {\n            iterator(memo, v, k, cb);\n        }, function(err) {\n            callback(err, memo);\n        });\n    };\n\n    function _filter(eachfn, arr, iterator, callback) {\n        var results = [];\n        eachfn(arr, function (x, index, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            });\n        }, function () {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    }\n\n    async.select =\n    async.filter = doParallel(_filter);\n\n    async.selectLimit =\n    async.filterLimit = doParallelLimit(_filter);\n\n    async.selectSeries =\n    async.filterSeries = doSeries(_filter);\n\n    function _reject(eachfn, arr, iterator, callback) {\n        _filter(eachfn, arr, function(value, cb) {\n            iterator(value, function(v) {\n                cb(!v);\n            });\n        }, callback);\n    }\n    async.reject = doParallel(_reject);\n    async.rejectLimit = doParallelLimit(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    function _createTester(eachfn, check, getResult) {\n        return function(arr, limit, iterator, cb) {\n            function done() {\n                if (cb) cb(getResult(false, void 0));\n            }\n            function iteratee(x, _, callback) {\n                if (!cb) return callback();\n                iterator(x, function (v) {\n                    if (cb && check(v)) {\n                        cb(getResult(true, x));\n                        cb = iterator = false;\n                    }\n                    callback();\n                });\n            }\n            if (arguments.length > 3) {\n                eachfn(arr, limit, iteratee, done);\n            } else {\n                cb = iterator;\n                iterator = limit;\n                eachfn(arr, iteratee, done);\n            }\n        };\n    }\n\n    async.any =\n    async.some = _createTester(async.eachOf, toBool, identity);\n\n    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);\n\n    async.all =\n    async.every = _createTester(async.eachOf, notId, notId);\n\n    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);\n\n    function _findGetResult(v, x) {\n        return x;\n    }\n    async.detect = _createTester(async.eachOf, identity, _findGetResult);\n    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);\n    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                callback(null, _map(results.sort(comparator), function (x) {\n                    return x.value;\n                }));\n            }\n\n        });\n\n        function comparator(left, right) {\n            var a = left.criteria, b = right.criteria;\n            return a < b ? -1 : a > b ? 1 : 0;\n        }\n    };\n\n    async.auto = function (tasks, concurrency, callback) {\n        if (typeof arguments[1] === 'function') {\n            // concurrency is optional, shift the args.\n            callback = concurrency;\n            concurrency = null;\n        }\n        callback = _once(callback || noop);\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length;\n        if (!remainingTasks) {\n            return callback(null);\n        }\n        if (!concurrency) {\n            concurrency = remainingTasks;\n        }\n\n        var results = {};\n        var runningTasks = 0;\n\n        var hasError = false;\n\n        var listeners = [];\n        function addListener(fn) {\n            listeners.unshift(fn);\n        }\n        function removeListener(fn) {\n            var idx = _indexOf(listeners, fn);\n            if (idx >= 0) listeners.splice(idx, 1);\n        }\n        function taskComplete() {\n            remainingTasks--;\n            _arrayEach(listeners.slice(0), function (fn) {\n                fn();\n            });\n        }\n\n        addListener(function () {\n            if (!remainingTasks) {\n                callback(null, results);\n            }\n        });\n\n        _arrayEach(keys, function (k) {\n            if (hasError) return;\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = _restParam(function(err, args) {\n                runningTasks--;\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _forEachOf(results, function(val, rkey) {\n                        safeResults[rkey] = val;\n                    });\n                    safeResults[k] = args;\n                    hasError = true;\n\n                    callback(err, safeResults);\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            });\n            var requires = task.slice(0, task.length - 1);\n            // prevent dead-locks\n            var len = requires.length;\n            var dep;\n            while (len--) {\n                if (!(dep = tasks[requires[len]])) {\n                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));\n                }\n                if (_isArray(dep) && _indexOf(dep, k) >= 0) {\n                    throw new Error('Has cyclic dependencies');\n                }\n            }\n            function ready() {\n                return runningTasks < concurrency && _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            }\n            if (ready()) {\n                runningTasks++;\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                addListener(listener);\n            }\n            function listener() {\n                if (ready()) {\n                    runningTasks++;\n                    removeListener(listener);\n                    task[task.length - 1](taskCallback, results);\n                }\n            }\n        });\n    };\n\n\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var DEFAULT_INTERVAL = 0;\n\n        var attempts = [];\n\n        var opts = {\n            times: DEFAULT_TIMES,\n            interval: DEFAULT_INTERVAL\n        };\n\n        function parseTimes(acc, t){\n            if(typeof t === 'number'){\n                acc.times = parseInt(t, 10) || DEFAULT_TIMES;\n            } else if(typeof t === 'object'){\n                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;\n                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;\n            } else {\n                throw new Error('Unsupported argument type for \\'times\\': ' + typeof t);\n            }\n        }\n\n        var length = arguments.length;\n        if (length < 1 || length > 3) {\n            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');\n        } else if (length <= 2 && typeof times === 'function') {\n            callback = task;\n            task = times;\n        }\n        if (typeof times !== 'function') {\n            parseTimes(opts, times);\n        }\n        opts.callback = callback;\n        opts.task = task;\n\n        function wrappedTask(wrappedCallback, wrappedResults) {\n            function retryAttempt(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            }\n\n            function retryInterval(interval){\n                return function(seriesCallback){\n                    setTimeout(function(){\n                        seriesCallback(null);\n                    }, interval);\n                };\n            }\n\n            while (opts.times) {\n\n                var finalAttempt = !(opts.times-=1);\n                attempts.push(retryAttempt(opts.task, finalAttempt));\n                if(!finalAttempt && opts.interval > 0){\n                    attempts.push(retryInterval(opts.interval));\n                }\n            }\n\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || opts.callback)(data.err, data.result);\n            });\n        }\n\n        // If a callback is passed, run this as a controll flow\n        return opts.callback ? wrappedTask() : wrappedTask;\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = _once(callback || noop);\n        if (!_isArray(tasks)) {\n            var err = new Error('First argument to waterfall must be an array of functions');\n            return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        function wrapIterator(iterator) {\n            return _restParam(function (err, args) {\n                if (err) {\n                    callback.apply(null, [err].concat(args));\n                }\n                else {\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    ensureAsync(iterator).apply(null, args);\n                }\n            });\n        }\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    function _parallel(eachfn, tasks, callback) {\n        callback = callback || noop;\n        var results = _isArrayLike(tasks) ? [] : {};\n\n        eachfn(tasks, function (task, key, callback) {\n            task(_restParam(function (err, args) {\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                results[key] = args;\n                callback(err);\n            }));\n        }, function (err) {\n            callback(err, results);\n        });\n    }\n\n    async.parallel = function (tasks, callback) {\n        _parallel(async.eachOf, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel(_eachOfLimit(limit), tasks, callback);\n    };\n\n    async.series = function(tasks, callback) {\n        _parallel(async.eachOfSeries, tasks, callback);\n    };\n\n    async.iterator = function (tasks) {\n        function makeCallback(index) {\n            function fn() {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            }\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        }\n        return makeCallback(0);\n    };\n\n    async.apply = _restParam(function (fn, args) {\n        return _restParam(function (callArgs) {\n            return fn.apply(\n                null, args.concat(callArgs)\n            );\n        });\n    });\n\n    function _concat(eachfn, arr, fn, callback) {\n        var result = [];\n        eachfn(arr, function (x, index, cb) {\n            fn(x, function (err, y) {\n                result = result.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, result);\n        });\n    }\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        callback = callback || noop;\n        if (test()) {\n            var next = _restParam(function(err, args) {\n                if (err) {\n                    callback(err);\n                } else if (test.apply(this, args)) {\n                    iterator(next);\n                } else {\n                    callback.apply(null, [null].concat(args));\n                }\n            });\n            iterator(next);\n        } else {\n            callback(null);\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        var calls = 0;\n        return async.whilst(function() {\n            return ++calls <= 1 || test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.until = function (test, iterator, callback) {\n        return async.whilst(function() {\n            return !test.apply(this, arguments);\n        }, iterator, callback);\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        return async.doWhilst(iterator, function() {\n            return !test.apply(this, arguments);\n        }, callback);\n    };\n\n    async.during = function (test, iterator, callback) {\n        callback = callback || noop;\n\n        var next = _restParam(function(err, args) {\n            if (err) {\n                callback(err);\n            } else {\n                args.push(check);\n                test.apply(this, args);\n            }\n        });\n\n        var check = function(err, truth) {\n            if (err) {\n                callback(err);\n            } else if (truth) {\n                iterator(next);\n            } else {\n                callback(null);\n            }\n        };\n\n        test(check);\n    };\n\n    async.doDuring = function (iterator, test, callback) {\n        var calls = 0;\n        async.during(function(next) {\n            if (calls++ < 1) {\n                next(null, true);\n            } else {\n                test.apply(this, arguments);\n            }\n        }, iterator, callback);\n    };\n\n    function _queue(worker, concurrency, payload) {\n        if (concurrency == null) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new Error('Concurrency must not be zero');\n        }\n        function _insert(q, data, pos, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0 && q.idle()) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    callback: callback || noop\n                };\n\n                if (pos) {\n                    q.tasks.unshift(item);\n                } else {\n                    q.tasks.push(item);\n                }\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n            });\n            async.setImmediate(q.process);\n        }\n        function _next(q, tasks) {\n            return function(){\n                workers -= 1;\n\n                var removed = false;\n                var args = arguments;\n                _arrayEach(tasks, function (task) {\n                    _arrayEach(workersList, function (worker, index) {\n                        if (worker === task && !removed) {\n                            workersList.splice(index, 1);\n                            removed = true;\n                        }\n                    });\n\n                    task.callback.apply(task, args);\n                });\n                if (q.tasks.length + workers === 0) {\n                    q.drain();\n                }\n                q.process();\n            };\n        }\n\n        var workers = 0;\n        var workersList = [];\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            payload: payload,\n            saturated: noop,\n            empty: noop,\n            drain: noop,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n                _insert(q, data, false, callback);\n            },\n            kill: function () {\n                q.drain = noop;\n                q.tasks = [];\n            },\n            unshift: function (data, callback) {\n                _insert(q, data, true, callback);\n            },\n            process: function () {\n                while(!q.paused && workers < q.concurrency && q.tasks.length){\n\n                    var tasks = q.payload ?\n                        q.tasks.splice(0, q.payload) :\n                        q.tasks.splice(0, q.tasks.length);\n\n                    var data = _map(tasks, function (task) {\n                        return task.data;\n                    });\n\n                    if (q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    workersList.push(tasks[0]);\n                    var cb = only_once(_next(q, tasks));\n                    worker(data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            workersList: function () {\n                return workersList;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                var resumeCount = Math.min(q.concurrency, q.tasks.length);\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= resumeCount; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    }\n\n    async.queue = function (worker, concurrency) {\n        var q = _queue(function (items, cb) {\n            worker(items[0], cb);\n        }, concurrency, 1);\n\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n            return a.priority - b.priority;\n        }\n\n        function _binarySearch(sequence, item, compare) {\n            var beg = -1,\n                end = sequence.length - 1;\n            while (beg < end) {\n                var mid = beg + ((end - beg + 1) >>> 1);\n                if (compare(item, sequence[mid]) >= 0) {\n                    beg = mid;\n                } else {\n                    end = mid - 1;\n                }\n            }\n            return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n            if (callback != null && typeof callback !== \"function\") {\n                throw new Error(\"task callback must be a function\");\n            }\n            q.started = true;\n            if (!_isArray(data)) {\n                data = [data];\n            }\n            if(data.length === 0) {\n                // call drain immediately if there are no tasks\n                return async.setImmediate(function() {\n                    q.drain();\n                });\n            }\n            _arrayEach(data, function(task) {\n                var item = {\n                    data: task,\n                    priority: priority,\n                    callback: typeof callback === 'function' ? callback : noop\n                };\n\n                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n                if (q.tasks.length === q.concurrency) {\n                    q.saturated();\n                }\n                async.setImmediate(q.process);\n            });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n            _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        return _queue(worker, 1, payload);\n    };\n\n    function _console_fn(name) {\n        return _restParam(function (fn, args) {\n            fn.apply(null, args.concat([_restParam(function (err, args) {\n                if (typeof console === 'object') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _arrayEach(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            })]));\n        });\n    }\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        var has = Object.prototype.hasOwnProperty;\n        hasher = hasher || identity;\n        var memoized = _restParam(function memoized(args) {\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (has.call(memo, key)) {   \n                async.setImmediate(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (has.call(queues, key)) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([_restParam(function (args) {\n                    memo[key] = args;\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                        q[i].apply(null, args);\n                    }\n                })]));\n            }\n        });\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n        return function () {\n            return (fn.unmemoized || fn).apply(null, arguments);\n        };\n    };\n\n    function _times(mapper) {\n        return function (count, iterator, callback) {\n            mapper(_range(count), iterator, callback);\n        };\n    }\n\n    async.times = _times(async.map);\n    async.timesSeries = _times(async.mapSeries);\n    async.timesLimit = function (count, limit, iterator, callback) {\n        return async.mapLimit(_range(count), limit, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return _restParam(function (args) {\n            var that = this;\n\n            var callback = args[args.length - 1];\n            if (typeof callback == 'function') {\n                args.pop();\n            } else {\n                callback = noop;\n            }\n\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {\n                    cb(err, nextargs);\n                })]));\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        });\n    };\n\n    async.compose = function (/* functions... */) {\n        return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n\n    function _applyEach(eachfn) {\n        return _restParam(function(fns, args) {\n            var go = _restParam(function(args) {\n                var that = this;\n                var callback = args.pop();\n                return eachfn(fns, function (fn, _, cb) {\n                    fn.apply(that, args.concat([cb]));\n                },\n                callback);\n            });\n            if (args.length) {\n                return go.apply(this, args);\n            }\n            else {\n                return go;\n            }\n        });\n    }\n\n    async.applyEach = _applyEach(async.eachOf);\n    async.applyEachSeries = _applyEach(async.eachOfSeries);\n\n\n    async.forever = function (fn, callback) {\n        var done = only_once(callback || noop);\n        var task = ensureAsync(fn);\n        function next(err) {\n            if (err) {\n                return done(err);\n            }\n            task(next);\n        }\n        next();\n    };\n\n    function ensureAsync(fn) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            args.push(function () {\n                var innerArgs = arguments;\n                if (sync) {\n                    async.setImmediate(function () {\n                        callback.apply(null, innerArgs);\n                    });\n                } else {\n                    callback.apply(null, innerArgs);\n                }\n            });\n            var sync = true;\n            fn.apply(this, args);\n            sync = false;\n        });\n    }\n\n    async.ensureAsync = ensureAsync;\n\n    async.constant = _restParam(function(values) {\n        var args = [null].concat(values);\n        return function (callback) {\n            return callback.apply(this, args);\n        };\n    });\n\n    async.wrapSync =\n    async.asyncify = function asyncify(func) {\n        return _restParam(function (args) {\n            var callback = args.pop();\n            var result;\n            try {\n                result = func.apply(this, args);\n            } catch (e) {\n                return callback(e);\n            }\n            // if result is Promise object\n            if (_isObject(result) && typeof result.then === \"function\") {\n                result.then(function(value) {\n                    callback(null, value);\n                })[\"catch\"](function(err) {\n                    callback(err.message ? err : new Error(err));\n                });\n            } else {\n                callback(null, result);\n            }\n        });\n    };\n\n    // Node.js\n    if (typeof module === 'object' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define === 'function' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","'use strict';\n\nexport default ($compile) => {\n  'ngInject';\n\n  return {\n    restrict: 'A',\n    replace: true,\n    link: (scope, ele, attrs) => {\n      scope.$watch(attrs.compiled, function (html) {\n        ele.html(html);\n        $compile(ele.contents())(scope);\n      });\n    }\n  };\n}\n","'use strict';\n\nvar angular = require('angular');\n\nimport directive from './ng-tree-view.directive';\nimport compiled from './directive.compiled';\nimport controller from './ng-tree-view.controller';\n\nangular\n  .module('ngTreeView', [])\n  .controller('NgTreeViewController', controller)\n  .directive('ngTreeView', directive)\n  .directive('compiled', compiled);\n","'use strict';\n\nimport async from 'async';\nimport templates from './templates';\n\nexport default ($scope, $timeout, $q) => {\n  'ngInject';\n\n  $scope.templates = templates;\n\n  $scope.cache = {};\n\n  $scope.options = {\n    id: $scope._options.id || 0,\n    lazy: $scope._options.lazy || false,\n    indicators: angular.extend({\n      folded: \"[+]\",\n      unfolded: \"[-]\",\n      loading: \"[...]\"\n    }, $scope._options.indicators || {})\n  }\n\n  $scope._lastSelectedItem = null;\n\n  $scope.shouldLoad = $scope._options.shouldLoad || ((item) => {\n    return true;\n  });\n\n  $scope.onSelect = $scope._options.onSelect || ((item) => {\n    let d = $q.deer();\n    d.resolve()\n    return d.promise;\n  })\n\n  $scope.itemSelected = (item) => {\n    $scope.onSelect(item)\n      .then(() => {\n        if ($scope._lastSelectedItem) {\n          $scope._lastSelectedItem._ngTree.selected = false;\n        }\n\n        item._ngTree.selected = true;\n        $scope._lastSelectedItem = item;\n      });\n  }\n\n  $scope.load = $scope._options.load || ((item) => {\n    let d = $q.defer();\n    d.resolve([]);\n    return d.promise;\n  });\n\n  $scope.pre = $scope._options.pre || ((item) => {\n    let d = $q.defer();\n    d.resolve([]);\n    return d.promise;\n  });\n\n  $scope.toggleFolding = (item, next) =>  {\n    next = next || (() => {});\n\n    // Return if it is already unfolded state\n    if (!item._ngTree.folded) {\n      item._ngTree.folded = true;\n      return next(null, item);\n    }\n\n    // Return if it is already loaded\n    //console.log(item.name + ' -> ' + JSON.stringify(item._ngTree));\n\n    if (item._ngTree.status === 'loaded') {\n      item._ngTree.folded = !item._ngTree.folded;\n      return next(null, item);\n    }\n\n    var _shouldLoad = $scope.options.lazy || false;\n\n    if (item._options && item._options.hasOwnProperty('lazy')) {\n      _shouldLoad = item._options.lazy;\n    }\n\n    if (!_shouldLoad) {\n      item._ngTree.folded = !item._ngTree.folded;\n      return next(null, item);\n    }\n\n    item._ngTree.status = 'loading';\n\n    $scope.load(item)\n      .then((children) => {\n        item.children = $scope._initItems(children);\n        item._ngTree.status = 'loaded';\n        item._ngTree.folded = !item._ngTree.folded;\n        item.children.forEach((c) => {\n          c.parent = item.id.toString();\n        });\n      });\n  }\n\n  $scope._initItem = (item) => {\n    item._ngTree = angular.extend(item._ngTree || {\n      folded: true,\n      selected: false\n    }, item._options || {});\n\n    if (!angular.isArray((item.children || []))) {\n      item.children = [];\n    }\n\n    if (item._ngTree.selected) {\n      $scope._lastSelectedItem = item;\n    }\n\n    $scope.cache[item.id.toString()] = item;\n\n    if (!item._ngTree.folded) {\n      item._ngTree.folded = !item._ngTree.folded;\n      $scope.toggleFolding(item);\n    }\n\n    return item;\n  }\n\n  $scope._initItems = (items) => {\n    return items.map((item) => {\n      return $scope._initItem(item);\n    });\n  }\n\n  $scope.tree = $scope._initItems($scope._options.data);\n\n  //$scope.pre()\n    //.then((path) => {\n      //async.mapSeries(path || [], (id, next) => {\n        //if (!$scope.cache[id]) return next();\n        //$scope.toggleFolding($scope.cache[id], next);\n      //}, (err, items) => {\n        //if (err) return console.log('couldnt load path');\n\n        //if (items.length) {\n          //var lastItem = $scope.cache[path[path.length - 1]];\n          //$scope.itemSelected(lastItem);\n        //}\n      //});\n    //});\n}\n","'use strict';\n\nimport templates from './templates';\n\nexport default () => {\n  'ngInject';\n\n  return {\n    template: templates.tree,\n    scope: {\n      _options: '=ngTreeView'\n    },\n    controller: 'NgTreeViewController',\n    link: (scope, element, attributes) => {}\n  };\n}\n","'use strict';\n\nconst tree = () => `\n  <ul>\n    <li ng-repeat=\"item in tree track by $index\" compiled=\"templates.item\" ng-class=\"{'selected': item._ngTree.selected}\"></li>\n  </ul>\n`;\n\nconst item = () => `\n  <div class='ng-tree-item-content'>\n    <span ng-show=\"item._ngTree.status !== 'loading'\">\n      <span ng-click=\"toggleFolding(item)\" ng-show=\"item._ngTree.folded\" compiled=\"options.indicators.folded\"></span>\n      <span ng-click=\"toggleFolding(item)\" ng-show=\"!item._ngTree.folded\" compiled=\"options.indicators.unfolded\"></span>\n    </span>\n\n    <span ng-show=\"item._ngTree.status === 'loading'\" compiled=\"options.indicators.loading\"></span>\n\n    <div class=\"folder-name\" ng-class=\"{'selected': item._ngTree.selected}\">\n      <a href=\"#\" ng-click=\"itemSelected(item)\">\n        {{item.name}}\n      </a>\n    </div>\n\n  </div>\n\n  <ul ng-if=\"!item._ngTree.folded\">\n    <li ng-repeat=\"item in item.children track by $index\" compiled=\"templates.item\" ng-class=\"{'selected': item._ngTree.selected}\"></li>\n  </ul>\n`;\n\nexport default {\n  item: item(),\n  tree: tree()\n}\n"],"sourceRoot":"/source/"}